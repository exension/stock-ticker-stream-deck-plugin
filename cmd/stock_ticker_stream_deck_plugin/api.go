package main

import (
	"bytes"
	"compress/gzip"
	"encoding/json"
	"io"
	"io/ioutil"
	"log"
	"net/http"
	"net/url"
	"strings"
)

const apiURL = "https://query1.finance.yahoo.com/v7/finance/quote?lang=en-US&region=US&corsDomain=finance.yahoo.com&fields=symbol,marketState,regularMarketPrice,regularMarketChange,regularMarketChangePercent,preMarketPrice,preMarketChange,preMarketChangePercent,postMarketPrice,postMarketChange,postMarketChangePercent"

// AutoGenerated struct from API response
// https://mholt.github.io/json-to-go/
type AutoGenerated struct {
	QuoteResponse QuoteResponse `json:"quoteResponse"`
}

// Result autogenerated
type Result struct {
	Language                   string  `json:"language"`
	Region                     string  `json:"region"`
	QuoteType                  string  `json:"quoteType"`
	QuoteSourceName            string  `json:"quoteSourceName"`
	Triggerable                bool    `json:"triggerable"`
	SourceInterval             int     `json:"sourceInterval"`
	ExchangeDataDelayedBy      int     `json:"exchangeDataDelayedBy"`
	FirstTradeDateMilliseconds int64   `json:"firstTradeDateMilliseconds"`
	PriceHint                  int     `json:"priceHint"`
	PreMarketChangePercent     float64 `json:"preMarketChangePercent"`
	PreMarketTime              int     `json:"preMarketTime"`
	PreMarketPrice             float64 `json:"preMarketPrice"`
	PreMarketChange            float64 `json:"preMarketChange"`
	PostMarketChangePercent    float64 `json:"postMarketChangePercent"`
	PostMarketTime             int     `json:"postMarketTime"`
	PostMarketPrice            float64 `json:"postMarketPrice"`
	PostMarketChange           float64 `json:"postMarketChange"`
	RegularMarketChange        float64 `json:"regularMarketChange"`
	RegularMarketChangePercent float64 `json:"regularMarketChangePercent"`
	RegularMarketTime          int     `json:"regularMarketTime"`
	RegularMarketPrice         float64 `json:"regularMarketPrice"`
	RegularMarketPreviousClose float64 `json:"regularMarketPreviousClose"`
	FullExchangeName           string  `json:"fullExchangeName"`
	ExchangeTimezoneName       string  `json:"exchangeTimezoneName"`
	ExchangeTimezoneShortName  string  `json:"exchangeTimezoneShortName"`
	GmtOffSetMilliseconds      int     `json:"gmtOffSetMilliseconds"`
	Market                     string  `json:"market"`
	EsgPopulated               bool    `json:"esgPopulated"`
	MarketState                string  `json:"marketState"`
	Exchange                   string  `json:"exchange"`
	Tradeable                  bool    `json:"tradeable"`
	Symbol                     string  `json:"symbol"`
}

// QuoteResponse autogenerated
type QuoteResponse struct {
	Result []Result    `json:"result"`
	Error  interface{} `json:"error"`
}

type apiResult struct {
	Result []Result `json:"result"`
}

// CallAPI makes HTTP request for stock data
func CallAPI(symbols []string) map[string]Result {
	if len(symbols) == 0 {
		return nil
	}

	client := &http.Client{}

	url, _ := url.Parse(apiURL)
	qp := url.Query()
	qp.Add("symbols", strings.Join(symbols, ","))
	url.RawQuery = qp.Encode()

	req, err := http.NewRequest("GET", url.String(), nil)
	if err != nil {
		log.Fatalln(err)
	}

	req.Header.Set("accept", "text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9")
	req.Header.Set("accept-encoding", "gzip, deflate, br")
	req.Header.Set("accept-language", "en-US,en;q=0.9")
	req.Header.Set("cache-control", "max-age=0")
	req.Header.Set("dnt", "1")
	req.Header.Set("sec-fetch-dest", "document")
	req.Header.Set("sec-fetch-mode", "navigate")
	req.Header.Set("sec-fetch-site", "none")
	req.Header.Set("sec-fetch-user", "?1")
	req.Header.Set("upgrade-insecure-requests", "1")
	req.Header.Set("user-agent", "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4324.182 Safari/537.36 Edg/88.0.705.81")

	resp, err := client.Do(req)
	if err != nil {
		log.Fatal(err)
	}

	if resp.StatusCode >= 300 {
		log.Printf("API response status code non 200: %d %s\n", resp.StatusCode, resp.Status)
		return nil
	}

	defer resp.Body.Close()

	var buf bytes.Buffer
	tee := io.TeeReader(resp.Body, &buf)

	var reader io.Reader
	reader, err = gzip.NewReader(tee)
	if err != nil {
		reader = &buf
	}
	body, err := ioutil.ReadAll(reader)
	if err != nil {
		log.Fatal(err)
	}

	var autogen AutoGenerated
	err = json.Unmarshal(body, &autogen)
	if err != nil {
		log.Fatal("body unmarshal", err)
	}

	ret := make(map[string]Result)
	for _, v := range autogen.QuoteResponse.Result {
		ret[v.Symbol] = v
	}

	return ret
}
